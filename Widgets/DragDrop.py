# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\test_table.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QDataStream, Qt
from PyQt5.QtWidgets import QListWidgetItem, QTableWidgetItem 
from matplotlib.pyplot import text
from Widgets.DataManipulate import data_manipulate

class Popup(QtWidgets.QDialog):
    def closeEvent(self, event):
        self.parent.main.tableDetail.make_table()

    def testCheck(self, item):
        fil = item.text()
        self.parent.dimension[self.name][fil] = not self.parent.dimension[self.name][fil]

    def __init__(self, name, parent):
        super().__init__(parent)
        self.resize(400, 300)
        self.name = name
        self.parent = parent
        self.label = QtWidgets.QLabel(self)
        self.label.setGeometry(QtCore.QRect(76, 30, 241, 20))
        self.label.setText(name)
        self.label.setAlignment(Qt.AlignCenter)
        self.listWidget = QtWidgets.QListWidget(self)
        self.listWidget.setGeometry(QtCore.QRect(70, 80, 256, 192))
        self.listWidget.itemChanged.connect(self.testCheck)
        self.selectButton = QtWidgets.QPushButton(self)
        self.selectButton.setGeometry(50, 50, 75, 20)
        self.selectButton.clicked.connect(self.selectFilter)
        self.selectButton.setText("select")
        self.clearButton = QtWidgets.QPushButton(self)
        self.clearButton.setGeometry(250, 50, 75, 20)
        self.clearButton.clicked.connect(self.clearFilter)
        self.clearButton.setText("clear")
        self.listWidget.setSortingEnabled(True)
        self.searchEdit = QtWidgets.QLineEdit(self)
        self.searchEdit.setGeometry(130, 50, 113, 20)
        self.createFilter()
        self.setLocale(QtCore.QLocale(QtCore.QLocale.English, QtCore.QLocale.UnitedStates))

        self.searchEdit.textEdited.connect(self.search)
    
    def search(self, e):
        if e == "":
            self.createFilter()
            return 
        for i in range(self.listWidget.count()):
            self.listWidget.takeItem(0)
        data = self.parent.dimension[self.name]
        for fil in data:
            if e in fil:
                item = QtWidgets.QListWidgetItem()
                item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
                if data[fil]:
                    item.setCheckState(QtCore.Qt.Checked)
                else:
                    item.setCheckState(QtCore.Qt.Unchecked)
                item.setData(QtCore.Qt.DisplayRole, fil)
                self.listWidget.addItem(item)

        
    
    def selectFilter(self):
        data = self.parent.dimension[self.name]
        for fil in data:
            self.parent.dimension[self.name][fil] = True
        self.createFilter()

    def clearFilter(self):
        data = self.parent.dimension[self.name]
        for fil in data:
            self.parent.dimension[self.name][fil] = False
        self.createFilter()
    
    def createFilter(self):
        for i in range(self.listWidget.count()):
            self.listWidget.takeItem(0)
            # self.listWidget.

        data = self.parent.dimension[self.name]
        for i in data:
            item = QtWidgets.QListWidgetItem()
            item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
            if data[i]:
                item.setCheckState(QtCore.Qt.Checked)
            else:
                item.setCheckState(QtCore.Qt.Unchecked)
            item.setData(QtCore.Qt.DisplayRole, i)
            self.listWidget.addItem(item)

class Popup(QtWidgets.QDialog):
    def closeEvent(self, event):
        self.parent.main.tableWidget.make_table()

    def testCheck(self, item):
        fil = item.text()
        self.parent.dimension[self.name][fil] = not self.parent.dimension[self.name][fil]

    def __init__(self, name, parent):
        super().__init__(parent)
        self.resize(400, 300)
        self.name = name
        self.parent = parent
        self.label = QtWidgets.QLabel(self)
        self.label.setGeometry(QtCore.QRect(76, 30, 241, 20))
        self.label.setText(name)
        self.label.setAlignment(Qt.AlignCenter)
        self.listWidget = QtWidgets.QListWidget(self)
        self.listWidget.setGeometry(QtCore.QRect(70, 80, 256, 192))
        self.listWidget.itemChanged.connect(self.testCheck)
        self.selectButton = QtWidgets.QPushButton(self)
        self.selectButton.setGeometry(50, 50, 75, 20)
        self.selectButton.clicked.connect(self.selectFilter)
        self.selectButton.setText("select")
        self.clearButton = QtWidgets.QPushButton(self)
        self.clearButton.setGeometry(250, 50, 75, 20)
        self.clearButton.clicked.connect(self.clearFilter)
        self.clearButton.setText("clear")
        self.listWidget.setSortingEnabled(True)
        self.searchEdit = QtWidgets.QLineEdit(self)
        self.searchEdit.setGeometry(130, 50, 113, 20)
        self.createFilter()
        self.setLocale(QtCore.QLocale(QtCore.QLocale.English, QtCore.QLocale.UnitedStates))

        self.searchEdit.textEdited.connect(self.search)
    
    def search(self, e):
        if e == "":
            self.createFilter()
            return 
        for i in range(self.listWidget.count()):
            self.listWidget.takeItem(0)
        data = self.parent.dimension[self.name]
        for fil in data:
            if e in fil:
                item = QtWidgets.QListWidgetItem()
                item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
                if data[fil]:
                    item.setCheckState(QtCore.Qt.Checked)
                else:
                    item.setCheckState(QtCore.Qt.Unchecked)
                item.setData(QtCore.Qt.DisplayRole, fil)
                self.listWidget.addItem(item)

        
    
    def selectFilter(self):
        data = self.parent.dimension[self.name]
        for fil in data:
            self.parent.dimension[self.name][fil] = True
        self.createFilter()

    def clearFilter(self):
        data = self.parent.dimension[self.name]
        for fil in data:
            self.parent.dimension[self.name][fil] = False
        self.createFilter()
    
    def createFilter(self):
        for i in range(self.listWidget.count()):
            self.listWidget.takeItem(0)
            # self.listWidget.

        data = self.parent.dimension[self.name]
        for i in data:
            item = QtWidgets.QListWidgetItem()
            item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
            if data[i]:
                item.setCheckState(QtCore.Qt.Checked)
            else:
                item.setCheckState(QtCore.Qt.Unchecked)
            item.setData(QtCore.Qt.DisplayRole, i)
            self.listWidget.addItem(item)

class DimensionList(QtWidgets.QListWidget):
    def __init__(self, main, parent):
        super(DimensionList, self).__init__(parent)
        self.dt = main.dt
        self.main = main
        self.dimension = {}

        self.itemDoubleClicked.connect(self.launchFilter)
    
    def launchFilter(self, item):
        pop = Popup(item.text(), self)
        pop.show()

    def dragLeaveEvent(self, e: QtGui.QDragLeaveEvent) -> None:
        if self.count():
            del self.dimension[self.item(self.currentRow()).text()]
            self.takeItem(self.currentRow())
            self.main.tableWidget.make_table()

    def readData(self, mime: QtCore.QMimeData) -> list:
        stream = QDataStream(mime.data('application/x-qabstractitemmodeldatalist'))
        textList = []
        while not stream.atEnd():
            # we're not using row and columns, but we *must* read them
            row = stream.readInt()
            col = stream.readInt()
            for dataSize in range(stream.readInt()):
                role, value = stream.readInt(), stream.readQVariant()
                if role == Qt.DisplayRole:
                    textList.append(value)
        return textList
    
    def dragEnterEvent(self, e: QtGui.QDragEnterEvent) -> None:
        col = self.readData(e.mimeData())[0]
        if self.dt.is_dimension(col):
            e.accept()
        else:
            e.ignore()
    
    def getFilter(self):
        result = {}
        for col in self.dimension:
            result[col] = []
            for fil in self.dimension[col]:
                if self.dimension[col][fil]:
                    result[col].append(fil)
        return result
    
    def addFilter(self, name:str) -> None:
        if name not in self.dimension.keys():
            self.dimension[name] = {}
            fil = self.dt.get_unique(name)
            for i in fil:
                self.dimension[name][i] = True

    def dropEvent(self, event: QtGui.QDropEvent) -> None:
        col = self.readData(event.mimeData())[0]
        self.addFilter(col)
        super().dropEvent(event)
        self.main.tableWidget.make_table()

class MeasureList(QtWidgets.QListWidget):
    def __init__(self, main, parent):
        super(MeasureList, self).__init__(parent)
        self.dt = main.dt
        self.main = main

    def dragLeaveEvent(self, e: QtGui.QDragLeaveEvent) -> None:
        if self.count():
            self.takeItem(self.currentRow())
            self.main.tableWidget.make_table()

    def readData(self, mime: QtCore.QMimeData) -> list:
        stream = QDataStream(mime.data('application/x-qabstractitemmodeldatalist'))
        textList = []
        while not stream.atEnd():
            # we're not using row and columns, but we *must* read them
            row = stream.readInt()
            col = stream.readInt()
            for dataSize in range(stream.readInt()):
                role, value = stream.readInt(), stream.readQVariant()
                if role == Qt.DisplayRole:
                    textList.append(value)
        return textList
    
    def isExist(self, s):
        for i in range(self.count()):
            if s.split('.')[0] == self.item(i).text().split('.')[0]:
                return True
        return False
    
    def dragEnterEvent(self, e: QtGui.QDragEnterEvent) -> None:
        col = self.readData(e.mimeData())[0]
        val = col.split('.')[0]
        if self.dt.is_measure(val):
            e.accept()
        else:
            e.ignore()
    
    def dropEvent(self, event: QtGui.QDropEvent) -> None:
        # super().dropEvent(event)
        col = self.readData(event.mimeData())[0]+".sum"
        if self.isExist(col):
            return
        item = QListWidgetItem()
        item.setText(col)
        self.addItem(item)
        self.main.tableWidget.make_table()

class TableGroupby(QtWidgets.QTableWidget):
    def __init__(self, main, parent):
        super(TableGroupby, self).__init__(parent)
        self.main = main
        self.dt = main.dt
        self.dimension = []
        self.measure = {}

    def make_table(self):
        self.setColumnCount(0)
        self.setRowCount(0)
        self.dimension = self.get_widget_item(self.main.DimensionList)
        self.dimension_filter = self.main.DimensionList.getFilter()
        self.measure_raw = self.get_widget_item(self.main.MeasureList)
        self.measure = self.to_measure_dict(self.measure_raw)
        # print(self.dimension_filter)
        if not(len(self.dimension) > 0 ):
            self.main.MeasureList.clear()
            return
        self.data_groupby = self.dt.get_groupby(self.dimension, self.measure, self.dimension_filter)
        self.header = self.data_groupby['col']
        self.data = self.data_groupby['data']
        self.setColumnCount(len(self.header))
        self.setRowCount(len(self.data))
        self.setHorizontalHeaderLabels(self.header)
        for row in range(len(self.data)):
            for col, item in enumerate(self.data[row]):
                if type(item) in (int, float):
                    newItem = QTableWidgetItem()
                    newItem.setData(QtCore.Qt.DisplayRole, item)
                else:
                    newItem = QTableWidgetItem(str(item))
                self.setItem(row, col, newItem)
    
    def get_widget_item(self, widget:QtWidgets.QListWidget) -> list :
        return [widget.item(i).text() for i in range(widget.count())]
    
    def to_measure_dict(self, measure: list):
        result = {}
        for i in measure:
            col = i.split('.')
            result[col[0]] = col[1]
        return result

    def add_listbox(self, e):
        col = self.readData(e.mimeData())[0]
        if self.dt.is_measure(col) and len(self.dimension) > 0:
            self.measure[col] = 'sum'
            col = col+'.sum'
            item = QListWidgetItem()
            item.setText(col)
            item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDropEnabled|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
            self.main.MeasureList.addItem(item)
            e.accept()
        elif self.dt.is_dimension(col):
            self.dimension.append(col)
            self.main.DimensionList.addFilter(col)
            self.main.DimensionList.addItem(col)
            e.accept()
    
    def dropEvent(self, event: QtGui.QDropEvent) -> None:
        self.add_listbox(event)
        if len(self.dimension) >0:
            self.make_table()

    def readData(self, mime: QtCore.QMimeData) -> list:
        stream = QDataStream(mime.data('application/x-qabstractitemmodeldatalist'))
        textList = []
        while not stream.atEnd():
            # we're not using row and columns, but we *must* read them
            row = stream.readInt()
            col = stream.readInt()
            for dataSize in range(stream.readInt()):
                role, value = stream.readInt(), stream.readQVariant()
                if role == Qt.DisplayRole:
                    textList.append(value)
        return textList